

// Include the bags and trees libraries (lists is included with these).
#include "library-bags.fz"
#include "library-trees.fz"

/* Also include shortcuts for numtree nodes for convenience */

typedef numtree = tree(num, bool);

function ntnode (p : num) (l : tree(num,bool)) (r : tree(num,bool)) : tree(num,bool) {
  node@[num]@[bool] p l r
}
leafT = leaf@[num]@[bool] true;
leafF = leaf@[num]@[bool] false;

/*
A database row is a list of bools.  The 0-indexed value is 
the label, and the parameters are indexed 1 through k.
*/
typedef boollist = list(bool);
typedef db = boollist bag;



// testTree takes a set of rows and a tree and returns the number of 
// times the tree correctly predicts the label for a row.
// testTree : db -o tree -> Fuzzy num
function testTree
  (bagtime : num)
  (t : numtree)
  (db :[] db)
  : fuzzy num
  {
    let (suc,fail) = bagsplit@[boollist]
        (fun (row : boollist) : bool {
            let (b,row') = index false 0.0 row;
            choose = fun (p : num) : bool { let (res,_) = (index@[bool] false p row'); res };
            runTree@[num]@[bool] choose t == b }) 100.0 db;
    return (bagsize@[boollist] suc)
  }


// chooseBestTree finds the best tree among those provided
// so long as it's better than the base tree's error adjusted 
// by the user provided function.
// chooseBestTree : tree -> (num -> num) -> list(tree) -> db -o Fuzzy (1 + tree)
function chooseBestTree
  (t : numtree)             // the base tree
  (cutoffMod : num -> num)  // the amount of error to beat
  (trees : numtree bag)     // the input trees
  (bagtime : num)           // the number of steps we use during bagsplit
  (db :[] db)               // the database
  : fuzzy numtree           // new tree
  {
    test : = fun (t' : numtree) { fun (d :[] db) : fuzzy num {
                  sample score = testTree bagtime t' d;
                  if t == t' then { return (cutoffMod score) }
                             else { return score } } };
    expMech@[numtree]@[db] 1.0 test (addtobag@[numtree] t trees) db
  }


// A function to return a list of nums [k .. 1]
function listNums (k : num) : list(num) {
  if (k <= 0.0) then { nil@[num] }
                else { cons@[num] k (listNums (k - 1.0)) }
}


function generateDecisionTreeHelper
  (k : num)
  (evalFun : num -> num -> num -> num -> num) //perhaps the last one should be -o?
  (delta : num)
  (epsilon : num)
  (t : numtree)
  : numtree
  {
    bools = cons@[bool] true (cons@[bool] false nil@[bool]);
    trees = listtobag@[numtree] (makeTrees@[num]@[bool] (listNums k) bools t);
    myfun = fun (x : num) : num { evalFun (bagsize@[numtree] trees) delta epsilon x };
    rz = runFuzz@[db]@[numtree] (chooseBestTree t myfun trees 100.0);
    case rz of {
      inl(unit) => t
    | inr(t') =>
        d = getDelta ();
        e = getEpsilon ();
        if (t == t') then { t' }
                     else { generateDecisionTreeHelper k evalFun d e t' }
    }
  }


// This green zone function calls chooseBestTree until a desired metric 
// is reached.
function generateDecisionTree
  (k : num)
  (evalFun : num -> num -> num -> num -> num) //perhaps the last one should be -o?
        //  length trees -> delta -> epsilon -> base tree score -> modified tree score
  : numtree
  { generateDecisionTreeHelper k (evalFun) 0.0 0.0 leafT }


function makeDB (k : num) : db {
  row1 : = cons@[bool] true  (cons@[bool] true  (cons@[bool] false nil@[bool]));
  row2 : = cons@[bool] true  (cons@[bool] true  (cons@[bool] true  nil@[bool]));
  row3 : = cons@[bool] false (cons@[bool] false (cons@[bool] false nil@[bool]));
  row4 : = cons@[bool] false (cons@[bool] false (cons@[bool] true  nil@[bool]));
  addtobag@[boollist] row1
    (addtobag@[boollist] row3
      (addtobag@[boollist] row3
        (addtobag@[boollist] row4
          (emptybag@[boollist]))))
}

function myeval (len : num) (delta : num) (eps : num) (bs : num) : num {
  bs
}

function main (arg : ()) : string {
  t : = generateDecisionTree 2.0 myeval;
  printTree@[num]@[bool] showNum showBool t

}

loadDB@[db] (makeDB 2.0) 5.0;
main ()
