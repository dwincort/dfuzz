// We use lists in bagpartition
#include "library-lists.fz"

/*

  Most functions dealing with bags are built-in in Fuzz.

  Here we recall their type signatures and their use. For a precise
  definition see the ICFP10 paper.

*/

//////////////////////////////////////////////////////////////////////
// Primitives (built-in)

/*
  emptybag : () -> A bag
  
  Creates an empty bag.
*/
primitive emptybag forall(A) : A bag { "emptybag" }

/*
  addtobag : A -o A bag -o A bag
  
  Adds the element to the bag.
*/
primitive addtobag forall(A) (x :[] A) (xs :[] A bag) : A bag { "addtobag" }

/*
  bagjoin : A bag -o A bag -o A bag
  
  Unions two bags together into a new bag.
*/
primitive bagjoin forall(A) (b1 :[] A bag) (b2 :[] A bag) : A bag { "bagjoin" }


/*
  bagsize : A bag -o num
  
  Given a bag it returns the number of elements in it.
*/
primitive bagsize forall(A) (b :[] A bag) : num { "bagsize" }

/*
  bagshow : string bag -o string
  
  Given a string bag, it shows the bag
*/
primitive bagshow (b :[] string bag) : string { "bagshow" }


/*
  bagFromFile : string -> bag DATA
  
  Given a file name, loads the data in the file into a bag
*/
primitive bagFromFile forall(DATA) (file : string) : DATA bag { "bagFromFile" }

/*
  listbagFromFile : string -> bag list(DATA)
  
  Given a file name, loads the data in the file into a bag
*/
primitive listbagFromFile forall(DATA) (file : string) : list(DATA) bag { "listbagFromFile" }

/*
  bagsplit : (A -> bool) -> num -> A bag -o ( A bag x A bag ) 

  Splits a bag in two bags: one containing the elements satisfying the
  test (the first argument), the other the elements that don't pass
  the test. The second argument (of type 'num') is the number ot steps
  we allow the function run.
*/
primitive bagsplit
   forall(A)
   (pred : A -> bool)
   (n    : num)
   (b    :[] A bag) : ( A bag,  A bag ) { "bagsplit" }

/*
  bagsplitins : (A -> bool) -> num -> A bag -o ( A bag x A bag ) 

  This is an "ins"ensitive version of bagsplit, and as such, 
  it does not require a number-of-steps argument.
*/
primitive bagsplitins
   forall(A)
   (pred : A -> bool)
   (b    : A bag) : ( A bag,  A bag ) { "bagsplitins" }

/*
  bagsum : (clipped bag) -o num

  Returns the sum of the elements of the bag.
*/
primitive bagsum (b :[] clipped bag) : num { "bagsum" }

/*
  bagfoldl : ((A, B) -o A) -> num -> A -o B bag -o A

  Folds the bag.  Requres a timeout argument which is the number of steps to run.
*/
primitive bagfoldl forall (A,B) 
  (f : (A,B) -o A)
  (timeout : num)
  (a :[] A)
  (b :[] B bag) : A { "bagfoldl" }

/*
  bagmap : (A -> B) -> num -> A bag -o B bag

  This is the straightforward adaptation of the classical map function
  on lists to the case of bags.  The second argument (of type 'num')
  is the number ot steps we allow the function to run.
*/
primitive bagmap forall (A,B) (f : A -> B) (timeout : num) (a :[] A bag) : B bag { "bagmap" }

/*
  bagmapins : (A -> B) -> A bag -> B bag

  This is an "ins"ensitive version of bagmap, and as such, 
  it does not require a number-of-steps argument.
*/
primitive bagmapins forall (A,B) (f : A -> B) (a : A bag) : B bag { "bagmapins" }

//////////////////////////////////////////////////////////////////////
// Utilities

/*
  listtobag : list(A) -o A bag
  
  Takes an ordered list and converts it into the less structured bag type.
*/
function listtobag forall(A) (lst :[] list(A)) : A bag {
  case (unfold lst) of {
    inl(unit) => emptybag@[A]
  | inr(xxs)  => let (x,xs) = xxs;
                 addtobag@[A] x (listtobag@[A] xs)
  }
}

/*
  bagfilter : (A -> Bool) -> num -> A bag -o A bag

  Returns a bag containing the elements of the input bag passing the
  test (the first argument).
*/
function bagfilter forall (A) (test: A -> bool) (timeout : num) (b:[] A bag) : A bag {
    let (yes, no) = bagsplit@[A] test timeout b;
    yes
}

/*
   bagpartition : list(K) -> num -> (K,A) bag -o list ((K,A) bag)

   bagpartition with counter
*/
function bagpartition forall (A, K) (klist: list(K)) (timeout : num) (db :[] (K, A) bag) : list((K,A) bag) {
    case unfold klist of {
      inl(x) => nil@[(K,A) bag]
    | inr(x) => let (k,ks) = x;
                let (db1, db2) = bagsplit@[(K,A)] 
                      (fun (y :[] (K,A)) : bool {
                        let (y1,y2) = y;
                        y1 == k}) timeout db;
                cons@[(K,A) bag] db1 (bagpartition@[A]@[K] ks timeout db2)
    }
}

