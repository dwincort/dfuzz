// We use lists in bagpartition
#include "library-lists.fz"

/*

  Most functions dealing with bags are built-in in Fuzz.

  Here we recall their type signatures and their use. For a precise
  definition see the ICFP10 paper.

*/

//////////////////////////////////////////////////////////////////////
// Primitives (built-in)

primitive emptybag forall(A) (x : ()) : A bag { "emptybag" }

primitive addtobag forall(A) (x :[] A) (xs :[] A bag) : A bag { "addtobag" }

function listtobag forall(A) (lst :[] list(A)) : A bag {
  case (unfold lst) of : {
    inl(unit) => emptybag@[A] ()
  | inr(xxs)  => let (x,xs) = xxs;
                 addtobag@[A] x (listtobag@[A] xs)
  }
}

primitive bagjoin forall(A) (b1 :[] A bag) (b2 :[] A bag) : A bag { "bagjoin" }


/*
  bagsize : A bag -o num Given a bag it returns the number of elements
  in it.
*/

primitive bagsize forall(A) (b :[] A bag) : num { "bagsize" }

/*
  bagsplit : (A -> bool) -> num -> A bag -o ( A bag x A bag ) 

  Splits a bag in two bags: one containing the elements satisfying the
  test (the first argument), the other the elements that don't pass
  the test. The second argument (of type 'num') is the number ot steps
  we allow the function run.
*/

primitive bagsplit
   forall(A)
   (pred : A -> bool)
   (n    : num)
   (b    :[] A bag) : ( A bag,  A bag ) { "bagsplit" }

/*
  bagsplitins : (A -> bool) -> num -> A bag -o ( A bag x A bag ) 

  This is an "ins"ensitive version of bagsplit, and as such, 
  it does not require a number-of-steps argument.
*/

primitive bagsplitins
   forall(A)
   (pred : A -> bool)
   (b    : A bag) : ( A bag,  A bag ) { "bagsplitins" }

/*
  bagsum : (num bag) -o num

  Returns the sum of the elements (clipped to the interval [-1,1]) of
  the input bag.
*/

primitive bagsum forall (A)
	   (b :[] A bag) : num { "bagsum" }

/*
  bagmap : (A -> B) -> num -> A bag -o B bag

  This is the straightforward adaptation of the classical map function
  on lists to the case of bags.  The second argument (of type 'num')
  is the number ot steps we allow the function to run.
*/

primitive bagmap forall (A,B) (f : A -> B) (timeout : num) (a :[] A bag) : B bag { "bagmap" }

/*
  bagmapins : (A -> B) -> A bag -> B bag

  This is an "ins"ensitive version of bagmap, and as such, 
  it does not require a number-of-steps argument.
*/

primitive bagmapins forall (A,B) (f : A -> B) (a : A bag) : B bag { "bagmapins" }

//////////////////////////////////////////////////////////////////////
// Utilities

/*
  bagfilter : (A -> Bool) -> num -> A bag -o A bag

  Returns a bag containing the elements of the input bag passing the
  test (the first argument).
*/

function bagfilter forall (A) (test: A -> bool) (timeout : num) (b:[] A bag) : A bag {
    let (yes, no) = bagsplit@[A] test timeout b;
    yes
}

/*
   bagpartition : list(K) -> num -> (K,A) bag -o list ((K,A) bag)

   bagpartition with counter
*/

function bagpartition forall (A, K) (klist: list(K)) (timeout : num) (db :[] (K, A) bag) : list((K,A) bag) {
    case unfold klist of : {
      inl(x) => nil((K,A) bag)
    | inr(x) => let (k,ks) = x;
                let (db1, db2) = bagsplit@[(K,A)] 
                      (fun (y :[] (K,A)) : bool {
                        let (y1,y2) = y;
                        y1 == k}) timeout db;
                cons((K,A) bag, db1, bagpartition@[A]@[K] ks timeout db2)
    }
}

