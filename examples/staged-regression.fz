

// Include the bags libraries (lists is included with this).
#include "library-bags.fz"

/*
A database row is a list of clipped nums.  The 0-indexed value is 
the label, and the parameters are indexed 1 through k.
*/



typedef nlist = list(num);
typedef clist = list(clipped);
typedef db = (clipped, clist) bag;

absum = fun (l : list(num)) : num { list_lfoldl@[num]@[num] (fun (accum :[] num) { fun (x :[] num ) { accum + (op_abs x) } }) 0 l };


function replicate forall(A) (x : A) (n : int) : list(A) {
  if n <= 0 then { nil@[A] } else { cons@[A] x (replicate@[A] x (n .- 1)) }
}


// Inner Product with a Fixed length and a Constant first list
function innerProdFC
  (v1 : list(num))
  (v2 :[[absum v1]] list(num))
  : num {
    case unfold v1 of {
      inl(_) => 0.0
    | inr(nns) => let (n,ns) = nns;
                  let (c,cs) = uncons@[num] 0.0 v2;
                  ipres = (scale n c) + (innerProdFC ns cs);
                  ipres
    }
}

      

function pairWithCount
  forall(A)
  (n : int)
  (lst :[] list(A))
  : list((int,A)) {
  case unfold lst of {
    inl(_)   => nil@[(int,A)]
  | inr(xxs) => let (x,xs) = xxs;
                cons@[(int,A)] (n,x) (pairWithCount@[A] (n .+ 1) xs)
  }
}

function rowop
  (beta : nlist)
  (row : (clipped, clist))
  : clist {
    let (y,rlst) = row;
    mew = innerProdFC beta rlst;
    betanorm = absum beta;
    list_map@[clipped]@[clipped] (fun (x : clipped) : clipped { 
        temp = (fromClip y - mew + betanorm) * (fromClip x);
        clip (temp / (betanorm + 1))
    }) rlst
}
  
function stagewiseRed
  (eps : num)
  (smallconstant : num)
  (dbSize : int)
  (threshold : num)
  (beta : nlist)
  (db :[[eps]] db)
  : fuzzy clist {
    // We need a list of zeros to begin accumulating the values we need
    len = length@[num] beta;
    //zeros = list_map@[num]@[num] (fun (x : num) : num { 0.0 }) beta;
    zeros = replicate@[num] 0.0 len;
    betanorm = absum beta;
    eps' = eps * 4 * (betanorm + 1);
    // This function f will be what we pass to the exponential mechanism
    f = fun (db :[[eps']] db) : (((int,num),num) bag) {
      // Get the average value of each column.  Start by summing them.
      sumVals = bagsumL len (bagmap@[(clipped, clist)]@[clist] (fun (ccs : (clipped, clist)) {let (_,cs) = ccs; cs}) db);
      // The main operation is a map then sum over the database using the above "rowop" function
      res = bagsumL len (bagmap@[(clipped, clist)]@[clist] (rowop beta) db);
      // The above result was shifted to make sure all values would be between 0 and 1.
      // We do a (|beta|+1)-sensitive operation to unshift and extract the results.
      res = zipWithS@[num]@[num]@[num] (betanorm + 1) 
              (fun (v :[[betanorm + 1]] num) { fun (c :[[betanorm + 1]] num) {
                (scale (betanorm + 1) v) - (scale betanorm c)}}) res sumVals;
      // The result of the fold is the current correlation vector c.  We pair each value with its index.
      res = pairWithCount@[num] 0 res;
      // We massage the data into a proper form for the expMechOnePass function.
      // Unfortunately, this is 2-sensitive because we need to use the value both 
      // as a score for the exponential mechanism as well as a result to check its sign.
      // TODO: Is there a way to reduce the sensitivity because we know that we'll only be using 
      // the sign of the value?
      res = list_lmap@[(int,num)]@[((int,num),num)] 2 (fun (xy :[2] (int,num)) : ((int,num),num) { let (i,n) = xy; ((i,n),op_abs n) }) res;
      // Convert the result to a bag and add the threshold value
      res = addtobag@[((int,num),num)] ((0 .- 1,threshold), threshold) (listtobag@[((int,num),num)] res);
      // return it in the probability monad.
      res };
    // Run the exponential mechanism.
    sample jcj = expMechOnePass@[(int,num)]@[db] eps' f db;
    // The result is both the index j and the value of c at j.
    let (j,cj) = jcj;
    if (j < 0) then {
      return beta
    } else {
      signedconstant = if cj > 0 then { smallconstant } else { 0 - smallconstant };
      return (performAt@[num] j (op_add signedconstant) beta)
    }
}

function stagewiseGreen
  (eps : num)
  (smallconstant : num)
  (dbSize : int)
  (threshold : num)
  (beta : nlist)
  : string {
    e = getEpsilon ();
    print ("We have "^showNum e^"*Îµ budget remaining and have so far produced beta="^showList@[num] showNum beta);
    rz = runFuzz'@[db]@[nlist] eps (stagewiseRed eps smallconstant dbSize threshold beta);
    case rz of {
      inl(s) => s
    | inr(beta') =>
        if (beta == beta') then { showList@[num] showNum beta }
                           else { stagewiseGreen eps smallconstant dbSize threshold beta' }
    }
}




db = (db = listbagFromFile@[num] "examples/data/baglist2.dat";
      db = bagmap@[nlist]@[clist]
            (fun (l : nlist) : clist {
              list_map@[num]@[clipped] (fun (x : num) : clipped { clip (x / 10.0) }) l}) db;
      bagmap@[clist]@[(clipped,clist)] (uncons (clip 0.0)) db);


// WHITE ZONE
loadDB@[db] db 300;
dbSize = bagsize@[(clipped,clist)] db;
stagewiseGreen 10 0.05 dbSize 0.05 (replicate@[num] 0.0 3)



