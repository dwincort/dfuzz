/* Copyright (c) 2013, The Trustees of the University of Pennsylvania
   All rights reserved.

   LICENSE: 3-clause BSD style.
   See the LICENSE file for details on licensing.
*/
////////////////////////////////////////////////////////////////////////
// Core primitives resulting from parser desugaring

// &-pair destruction
primitive fst forall (A,B) (p :[] (| A, B |) ) : A { "_fst" }
primitive snd forall (A,B) (p :[] (| A, B |) ) : B { "_snd" }

// Infix logical operators
primitive op_lor  (op1 : bool) (op2 : bool) : bool { "_lor" }
primitive op_land (op1 : bool) (op2 : bool) : bool { "_land" }

// Polymorphic equality
primitive op_eq   forall(A) (op1 :[] A) (op2 :[] A) : bool { "_eq" }
// FIXME: Should this be a primitive?
primitive op_neq  forall(A) (op1 :[] bool) (op2 :[] bool) : bool { "_neq" }

// Num primitives
// Numerical comparison
primitive op_lt   (op1 : num ) (op2 : num ) : bool { "_lt" }
primitive op_gt   (op1 : num ) (op2 : num ) : bool { "_gt" }
primitive op_lte  (op1 : num ) (op2 : num ) : bool { "_lte" }
primitive op_gte  (op1 : num ) (op2 : num ) : bool { "_gte" }

// Numerical Computation
primitive op_add (op1 :[] num ) (op2 :[] num )  : num { "_add" }
primitive op_sub (op1 :[] num ) (op2 :[] num )  : num { "_sub" }
primitive op_mul (op1 : num ) (op2 : num )      : num { "_mul" }
primitive op_div (op1 : num ) (op2 : num )      : num { "_div" }
primitive div2 (n : [0.5] num)                  : num { "div2" }
primitive div3 (n : [0.333] num)                : num { "div3" }
primitive op_exp (n : num )                     : num { "_exp" }
primitive op_abs (n : num )                     : num { "_abs" }

primitive const_mult (c : num) (n :[[c]] num)   : num { "_mul" }


// Careful! This is only sound if d >= 1.
primitive op_ldiv (d : num ) (n : num )     : num { "_ldiv" }

// Integer primitives
primitive op_iadd (op1 :[] int ) (op2 :[] int ) : int { "_iadd" }
primitive op_isub (op1 :[] int ) (op2 :[] int ) : int { "_isub" }
primitive op_imul (op1 : int ) (op2 : int ) : int { "_imul" }
primitive op_idiv (op1 : int ) (op2 : int ) : int { "_idiv" }

// Clip type creation
primitive clip (n :[] num) : clipped                     { "clip" }

// String primitives
primitive num2string (n : num) : string { "num2string" }
primitive string_concat (s1 : string) (s2 : string) : string { "string_cc" }

////////////////////////////////////////////////////////////////////////
// Probability monad, return and bind
primitive return   forall(A)   (x :[] A)                            : fuzzy A { "_return" }
// FIXME: sample is currently syntax instead of a primitive because of the lack of type inference
//primitive p_sample forall(A,B) (x :[] fuzzy A) (f :[] A -> fuzzy B) : fuzzy B { "_bind"   }

////////////////////////////////////////////////////////////////////////
// Red zone activation primitives:
typedef delta = num;
typedef epsilon = num;

primitive loadDB forall(DB)(db : DB) : () { "loadDB" }

primitive runFuzz
  forall(DB,A)
  (foo : DB -o fuzzy A)
  : (string + A) { "runRedZone" }

primitive getDelta   (x : ()) : delta   { "getDelta"   }
primitive getEpsilon (x : ()) : epsilon { "getEpsilon" }

////////////////////////////////////////////////////////////////////////
// Differential Privacy mechanisms:
primitive expMech
  forall(A,DB)
  (foo : A -> DB -o fuzzy num) 
  (rs : A bag) 
  (db :[] DB) 
  : fuzzy A { "expMech" }

////////////////////////////////////////////////////////////////////////
// Parsing primitives: (currently inactive)
// primitive parse_census (dbs :[] db_source) : (num, string, string, string, num, num, num, num) bag             { "parse_census" }
// primitive parse_apache (dbs :[] db_source) : ((int, int, int, int), string) bag                                { "parse_apache" }
// primitive parse_points (dbs :[] db_source) : (num, num) bag                                                    { "parse_points" }
// primitive parse_student (dbs:[] db_source) : (num, string, bool, clipped, bool, clipped, bool, clipped) bag    { "parse_student" }
// primitive parse_queries (dbs:[] db_source) : (clipped, clipped, clipped, clipped, clipped, clipped, clipped, clipped) bag { "parse_queries" }
