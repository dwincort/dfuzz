/* Copyright (c) 2013, The Trustees of the University of Pennsylvania
   All rights reserved.

   LICENSE: 3-clause BSD style.
   See the LICENSE file for details on licensing.
*/
////////////////////////////////////////////////////////////////////////
// Core primitives resulting from parser desugaring

// &-pair destruction
primitive fst forall (A,B) (p :[] (| A, B |) ) : A { "_fst" }
primitive snd forall (A,B) (p :[] (| A, B |) ) : B { "_snd" }

// Infix logical operators
primitive op_lor  (op1 : bool) (op2 : bool) : bool { "_lor" }
primitive op_land (op1 : bool) (op2 : bool) : bool { "_land" }

// Polymorphic equality
primitive op_eq   forall(A) (op1 :[] A) (op2 :[] A) : bool { "_eq" }
// FIXME: Should this be a primitive?
primitive op_neq  forall(A) (op1 :[] A) (op2 :[] A) : bool { "_neq" }

// Num primitives
// Numerical comparison
primitive op_lt   (op1 : num ) (op2 : num ) : bool { "_lt" }
primitive op_gt   (op1 : num ) (op2 : num ) : bool { "_gt" }
primitive op_lte  (op1 : num ) (op2 : num ) : bool { "_lte" }
primitive op_gte  (op1 : num ) (op2 : num ) : bool { "_gte" }

// Numerical Computation
primitive op_add (op1 :[] num ) (op2 :[] num )  : num { "_add" }
primitive op_sub (op1 :[] num ) (op2 :[] num )  : num { "_sub" }
primitive op_mul (op1 : num ) (op2 : num )      : num { "_mul" }
primitive op_div (op1 : num ) (op2 : num )      : num { "_div" }
primitive div2 (n : [0.5] num)                  : num { "div2" }
primitive div3 (n : [0.333] num)                : num { "div3" }
primitive op_exp (n : num )                     : num { "_exp" }
primitive op_abs (n : num )                     : num { "_abs" }

primitive const_mult (c : num) (n :[[c]] num)   : num { "_mul" }

// Integer primitives
primitive op_iadd (op1 :[] int ) (op2 :[] int ) : int { "_iadd" }
primitive op_isub (op1 :[] int ) (op2 :[] int ) : int { "_isub" }
primitive op_imul (op1 : int ) (op2 : int ) : int { "_imul" }
primitive op_idiv (op1 : int ) (op2 : int ) : int { "_idiv" }

// Clip type creation
primitive clip (n :[] num) : clipped                    { "clip" }
primitive fromClip (c :[] clipped) : num                { "fromClip" }

// Clip operations
primitive clip_mult (op1 :[] clipped) (op2 :[] clipped) : clipped { "_mul" }
primitive clip_scale (op1 :[] clipped) (op2 :[] num) : num { "_mul" }
primitive clip_plus (op1 :[] clipped) (op2 :[] clipped) : clipped { "_add" }

// String primitives
primitive string_concat (s1 :[] string) (s2 :[] string) : string { "string_cc" }

// Show functions
showBool = fun (b : bool) : string { if b then {"true"} else {"false"} };
primitive showNum (n : num) : string { "showNum" }

////////////////////////////////////////////////////////////////////////
// Testing utilities
primitive assert (s : string) (b :[["No asserts in red zone"]] bool) : () { "assert" }
primitive assertEq forall(A) (s : string) 
  (a1 :[["No asserts in red zone"]] A)
  (a2 :[["No asserts in red zone"]] A) : () { "assertEq" }

////////////////////////////////////////////////////////////////////////
// Probability monad, return and bind
primitive return   forall(A)   (x : A)                            : fuzzy A { "_return" }
// FIXME: sample is currently syntax instead of a primitive because of the lack of type inference
//primitive p_sample forall(A,B) (x :[] fuzzy A) (f :[] A -> fuzzy B) : fuzzy B { "_bind"   }

////////////////////////////////////////////////////////////////////////
// Red zone activation primitives:
typedef delta = num;
typedef epsilon = num;

primitive loadDB forall(DB) (db : DB) (budget : epsilon) : () { "loadDB" }

primitive runFuzz
  forall(DB,A)
  (foo : DB -o fuzzy A)
  : (string + A) { "runRedZone" }

primitive runFuzz'
  forall(DB,A)
  (sens : num)
  (foo : DB -o fuzzy A)
  : (string + A) { "runRedZoneS" }

primitive getDelta   (_ : ()) : delta   { "getDelta"   }
primitive getEpsilon (_ : ()) : epsilon { "getEpsilon" }

////////////////////////////////////////////////////////////////////////
// Differential Privacy mechanisms:
primitive add_noise
  (eps : num)
  (n :[[eps]] num)
  : fuzzy num { "addNoise" }

primitive expMech
  forall(A,DB)
  (eps : num)
  (foo : A -> DB -o fuzzy num) 
  (rs : A bag) 
  (db :[[eps]] DB) 
  : fuzzy A { "expMech" }

////////////////////////////////////////////////////////////////////////
// Parsing primitives: (currently inactive)
// primitive parse_census (dbs :[] db_source) : (num, string, string, string, num, num, num, num) bag             { "parse_census" }
// primitive parse_apache (dbs :[] db_source) : ((int, int, int, int), string) bag                                { "parse_apache" }
// primitive parse_points (dbs :[] db_source) : (num, num) bag                                                    { "parse_points" }
// primitive parse_student (dbs:[] db_source) : (num, string, bool, clipped, bool, clipped, bool, clipped) bag    { "parse_student" }
// primitive parse_queries (dbs:[] db_source) : (clipped, clipped, clipped, clipped, clipped, clipped, clipped, clipped) bag { "parse_queries" }
