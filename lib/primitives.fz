/* Copyright (c) 2013, The Trustees of the University of Pennsylvania
   All rights reserved.

   LICENSE: 3-clause BSD style.
   See the LICENSE file for details on licensing.
*/
////////////////////////////////////////////////////////////////////////
// Core primitives resulting from parser desugaring

// &-pair destruction
primitive fst forall (A,B) (p :[] (| A, B |) ) : A { "_fst" }
primitive snd forall (A,B) (p :[] (| A, B |) ) : B { "_snd" }

// Infix logical operators
primitive op_lor  (op1 : bool) (op2 : bool) : bool { "_lor" }
primitive op_land (op1 : bool) (op2 : bool) : bool { "_land" }

// Polymorphic equality
primitive op_eq   forall(A) (op1 :[] A) (op2 :[] A) : bool { "_eq" }
// FIXME: Should this be a primitive?
primitive op_neq  forall(A) (op1 :[] A) (op2 :[] A) : bool { "_neq" }

// Num primitives
// Numerical comparison
primitive op_lt   (op1 : num ) (op2 : num ) : bool { "_lt" }
primitive op_gt   (op1 : num ) (op2 : num ) : bool { "_gt" }
primitive op_lte  (op1 : num ) (op2 : num ) : bool { "_lte" }
primitive op_gte  (op1 : num ) (op2 : num ) : bool { "_gte" }

// Numerical Computation
primitive op_add (op1 :[] num ) (op2 :[] num )  : num { "_add" }
primitive op_sub (op1 :[] num ) (op2 :[] num )  : num { "_sub" }
primitive op_mul (op1 : num ) (op2 : num )      : num { "_mul" }
primitive op_div (op1 : num ) (op2 : num )      : num { "_div" }
primitive div2 (n : [0.5] num)                  : num { "div2" }
primitive div3 (n : [0.333] num)                : num { "div3" }
primitive op_exp (n : num )                     : num { "_exp" }
primitive op_abs (n :[] num )                   : num { "_abs" }
primitive cswp (xy :[] (num, num))              : (num, num) { "cswp" }
min = fun (xy :[] (num, num)) : num { let (x,y) = (cswp xy); x };
max = fun (xy :[] (num, num)) : num { let (x,y) = (cswp xy); y };

primitive scale (c : num) (n :[[op_abs c]] num)   : num { "_mul" }

// Integer primitives
primitive op_iadd (op1 :[] int ) (op2 :[] int ) : int { "_iadd" }
primitive op_isub (op1 :[] int ) (op2 :[] int ) : int { "_isub" }
primitive op_imul (op1 : int ) (op2 : int ) : int { "_imul" }
primitive op_idiv (op1 : int ) (op2 : int ) : int { "_idiv" }
primitive intToPeano (n :[] int) : (mu X => (() + X)) { "intToPeano" }
intToFloat = fun (x :[] num) : num { x };

// Clip type creation
primitive clip (n :[] num) : clipped                    { "clip" }
primitive fromClip (c :[] clipped) : num                { "fromClip" }

// Clip operations
primitive clip_mult (op1 :[] clipped) (op2 :[] clipped) : clipped { "_mul" }
primitive clip_scale (op1 :[] clipped) (op2 :[] num) : num { "_mul" }

// String primitives
primitive string_concat (s1 :[] string) (s2 :[] string) : string { "string_cc" }

// Show functions
showBool = fun (b : bool) : string { if b then {"true"} else {"false"} };
primitive showNum (n : num) : string { "showNum" }
primitive showInt (n : int) : string { "showInt" }
showClipped = fun (c : clipped) : string { showNum (fromClip c) };
function showPair forall(A,B) (pA : A -> string) (pB : B -> string) (p : (A,B)) : string {
  let (a,b) = p;
   "("^(pA a)^","^(pB b)^")"
}

////////////////////////////////////////////////////////////////////////
// Testing utilities
primitive assert 
  (s :[["No asserts in red zone"]] string) 
  (b :[["No asserts in red zone"]] bool) : () { "assert" }
primitive assertEq forall(A) 
  (s  :[["No asserts in red zone"]] string) 
  (a1 :[["No asserts in red zone"]] A)
  (a2 :[["No asserts in red zone"]] A) : () { "assertEq" }
primitive print 
  (s :[["No printing in red zone"]] string) : () { "print" }

////////////////////////////////////////////////////////////////////////
// Probability monad, return and bind
primitive return   forall(A)   (x : A)                            : fuzzy A { "_return" }
// FIXME: sample is currently syntax instead of a primitive because of the lack of type inference
//primitive p_sample forall(A,B) (x :[] fuzzy A) (f :[] A -> fuzzy B) : fuzzy B { "_bind"   }

////////////////////////////////////////////////////////////////////////
// Red zone activation primitives:
typedef delta = num;
typedef epsilon = num;

primitive loadDB forall(DB) (db : DB) (budget : epsilon) : () { "loadDB" }

primitive tyCheckFuzz 
  forall(DB,A) 
  (sens : num)
  (foo : DB -o[[sens]] A) 
  : (string + ()) { "tyCheckFuzz" }

primitive runFuzz
  forall(DB,A)
  (foo : DB -o fuzzy A)
  : (string + A) { "runRedZone" }

primitive runFuzz'
  forall(DB,A)
  (sens : num)
  (foo : DB -o[[sens]] fuzzy A)
  : (string + A) { "runRedZoneS" }

primitive getDelta   (_ : ()) : delta   { "getDelta"   }
primitive getEpsilon (_ : ()) : epsilon { "getEpsilon" }

function assertTyCheck forall(DB,A)
  (name : string)
  (shouldpass : bool)
  (sens : num)
  (foo : DB -o[[sens]] A) 
  : () {
  res = tyCheckFuzz@[DB]@[A] sens foo;
  case res of {
    inl(s) => if shouldpass then { assertEq@[string] name s "Success" } else { assert name true }
  | inr(_) => if shouldpass then { assert name true } else { assertEq@[string] name "Success" "Should Fail" }
  }
}

////////////////////////////////////////////////////////////////////////
// Differential Privacy mechanisms:
primitive add_noise
  (eps : num)
  (n :[[eps]] num)
  : fuzzy num { "addNoise" }

// Note that expMech can now be written in terms of expMechOnePass
primitive expMech
  forall(A,DB)
  (eps : num)
  (foo : A -> DB -o[[eps]] num) 
  (rs : A bag) 
  (db :[] DB) 
  : fuzzy A { "expMech" }

primitive expMechOnePass
  forall(A,DB)
  (eps : num)
  (foo : DB -o[[eps]] ((A,num) bag)) 
  (db :[] DB) 
  : fuzzy A { "expMechOnePass" }

////////////////////////////////////////////////////////////////////////
// Curry and uncurry
function curry forall(A,B,C)
  (f : (A, B) -o C)
  (a :[] A)
  (b :[] B)
  : C { f (a,b) }

function uncurry forall(A,B,C)
  (f : A -o B -o C)
  (ab :[] (A,B))
  : C { let (a,b) = ab; f a b }
